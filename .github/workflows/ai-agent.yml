name: AI Agent Assistant

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      provider:
        description: "Provider: openai or copilot"
        required: false
        default: openai
      model:
        description: Model (default GPT-5.1-Codex-Max)
        required: false
        default: GPT-5.1-Codex-Max
      prompt:
        description: Optional extra question/instruction for the agent
        required: false
        default: ''

permissions:
  contents: read
  pull-requests: write

jobs:
  agent:
    name: AI Agent
    runs-on: ubuntu-latest
    env:
      PROVIDER: ${{ github.event.inputs.provider || 'openai' }}
      MODEL: ${{ github.event.inputs.model || 'GPT-5.1-Codex-Max' }}
      PROMPT: ${{ github.event.inputs.prompt || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run AI agent
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          COPILOT_TOKEN: ${{ secrets.COPILOT_TOKEN }}
          MODEL: ${{ env.MODEL }}
          PROVIDER: ${{ env.PROVIDER }}
          PROMPT: ${{ env.PROMPT }}
        with:
          script: |
            module.exports = async ({ core, github, context }) => {
              const { execSync } = require('child_process');
              const crypto = require('crypto');

              const provider = (process.env.PROVIDER || 'openai').toLowerCase();
              const model = process.env.MODEL || 'GPT-5.1-Codex-Max';

              const isPR = context.eventName === 'pull_request';
              const pr = context.payload.pull_request;

              let baseSha = 'HEAD^';
              if (isPR) {
                baseSha = pr.base.sha;
              } else {
                try {
                  baseSha = execSync('git rev-parse HEAD^', { encoding: 'utf8' }).trim();
                } catch (error) {
                  baseSha = execSync('git rev-list --max-parents=0 HEAD', { encoding: 'utf8' }).trim();
                }
              }

              const headSha = context.sha;

              let diff = '';
              try {
                diff = execSync(`git diff ${baseSha}...${headSha}`, {
                  encoding: 'utf8',
                  maxBuffer: 20 * 1024 * 1024,
                });
              } catch (error) {
                core.warning(`Unable to compute diff: ${error.message}`);
              }

              const extraPrompt = process.env.PROMPT || '';

              if (!diff.trim() && !extraPrompt.trim()) {
                const message = 'No changes detected for analysis and no prompt provided.';
                if (isPR) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: message,
                  });
                } else {
                  core.info(message);
                }
                return;
              }

              const systemPrompt = 'You are an AI code agent for the CRM (PHP/Laravel + frontend). Provide concise, actionable suggestions to create/correct/improve code. Prefer specific steps and concrete code snippets. Highlight risks and missing tests. Keep output under 450 words.';
              const userPrompt = `Repository: ${context.repo.owner}/${context.repo.repo}\nEvent: ${context.eventName}\nBase: ${baseSha}\nHead: ${headSha}\nGoals: create new code, fix issues, and suggest improvements for the CRM.${extraPrompt ? `\nUser prompt: ${extraPrompt}` : ''}\nDiff (git diff base...head):\n${diff}`;

              async function callOpenAI() {
                if (!process.env.OPENAI_API_KEY) {
                  core.setFailed('OPENAI_API_KEY secret not found.');
                  return null;
                }
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
                  },
                  body: JSON.stringify({
                    model,
                    messages: [
                      { role: 'system', content: systemPrompt },
                      { role: 'user', content: userPrompt },
                    ],
                    temperature: 0.2,
                    max_tokens: 1200,
                  }),
                });

                if (!response.ok) {
                  const errText = await response.text();
                  core.setFailed(`OpenAI API error: ${response.status} ${response.statusText} - ${errText}`);
                  return null;
                }

                const data = await response.json();
                return data?.choices?.[0]?.message?.content?.trim() || 'No response content.';
              }

              async function callCopilot() {
                if (!process.env.COPILOT_TOKEN) {
                  core.setFailed('COPILOT_TOKEN secret not found. Provide a Copilot API token.');
                  return null;
                }

                const requestId = crypto.randomUUID();
                const response = await fetch('https://api.githubcopilot.com/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${process.env.COPILOT_TOKEN}`,
                    'X-Request-ID': requestId,
                  },
                  body: JSON.stringify({
                    model,
                    messages: [
                      { role: 'system', content: systemPrompt },
                      { role: 'user', content: userPrompt },
                    ],
                    temperature: 0.2,
                    max_tokens: 1200,
                  }),
                });

                if (!response.ok) {
                  const errText = await response.text();
                  core.setFailed(`Copilot API error: ${response.status} ${response.statusText} - ${errText}`);
                  return null;
                }

                const data = await response.json();
                return data?.choices?.[0]?.message?.content?.trim() || 'No response content.';
              }

              let content = null;
              if (provider === 'copilot') {
                content = await callCopilot();
              } else {
                content = await callOpenAI();
              }

              if (!content) {
                return;
              }

              const body = `ðŸ¤– AI Agent (${provider}/${model})\n\n${content}\n\n_Run: ${context.runId}_`;

              if (isPR) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body,
                });
              } else {
                core.setOutput('analysis', body);
                core.info(body);
              }
            };
