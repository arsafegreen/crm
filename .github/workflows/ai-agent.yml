name: AI Agent Assistant

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      provider:
        description: "Provider: openai or copilot"
        required: false
        default: openai
      model:
        description: Model (default GPT-5.1-Codex-Max)
        required: false
        default: GPT-5.1-Codex-Max
      prompt:
        description: Optional extra question/instruction for the agent
        required: false
        default: ''

permissions:
  contents: read
  pull-requests: write

jobs:
  agent:
    name: AI Agent
    runs-on: ubuntu-latest
    env:
      PROVIDER: ${{ github.event.inputs.provider || 'openai' }}
      MODEL: ${{ github.event.inputs.model || 'GPT-5.1-Codex-Max' }}
      PROMPT: ${{ github.event.inputs.prompt || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run AI agent
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          COPILOT_TOKEN: ${{ secrets.COPILOT_TOKEN }}
          MODEL: ${{ env.MODEL }}
          PROVIDER: ${{ env.PROVIDER }}
          PROMPT: ${{ env.PROMPT }}
        with:
          script: |
            const { execSync } = require('child_process');
            const crypto = require('crypto');

            async function run() {
              const provider = (process.env.PROVIDER || 'openai').toLowerCase();
              const model = process.env.MODEL || 'GPT-5.1-Codex-Max';

              const isPR = context.eventName === 'pull_request';
              const isIssueComment = context.eventName === 'issue_comment';
              const isPRComment = isIssueComment && !!context.payload.issue?.pull_request;
              const isManual = context.eventName === 'workflow_dispatch';

              // Only respond to /ai comments on PRs for issue_comment events
              let commentPrompt = '';
              if (isIssueComment) {
                if (!isPRComment) {
                  core.info('Comment is not on a pull request. Skipping.');
                  return;
                }
                const body = context.payload.comment?.body || '';
                const match = body.match(/^\/ai\s*(.*)$/is);
                if (!match) {
                  core.info('No /ai command found. Skipping.');
                  return;
                }
                commentPrompt = match[1].trim();
                if (!commentPrompt) {
                  core.setFailed('No prompt provided after /ai');
                  return;
                }
              }

              const prNumber = isPR ? context.payload.pull_request.number : (isPRComment ? context.payload.issue.number : null);
              let baseSha = 'HEAD^';
              let headSha = context.sha;

              if (prNumber) {
                const prData = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                baseSha = prData.data.base.sha;
                headSha = prData.data.head.sha;

                // Ensure commits are present locally for diff
                try {
                  execSync(`git fetch origin ${baseSha} ${headSha}`, { stdio: 'ignore' });
                } catch (error) {
                  core.warning(`Fetch failed: ${error.message}`);
                }
              } else if (isManual) {
                // Manual run without PR: use HEAD^...HEAD
                try {
                  baseSha = execSync('git rev-parse HEAD^', { encoding: 'utf8' }).trim();
                  headSha = execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim();
                } catch (error) {
                  core.warning(`Unable to resolve base/head for manual run: ${error.message}`);
                }
              }

              let diff = '';
              try {
                diff = execSync(`git diff ${baseSha}...${headSha}`, {
                  encoding: 'utf8',
                  maxBuffer: 20 * 1024 * 1024,
                });
              } catch (error) {
                core.warning(`Unable to compute diff: ${error.message}`);
              }

              const extraPrompt = isIssueComment ? commentPrompt : (process.env.PROMPT || '');

              if (!diff.trim() && !extraPrompt.trim()) {
                const message = 'No changes detected for analysis and no prompt provided.';
                if (prNumber) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: message,
                  });
                } else {
                  core.info(message);
                }
                return;
              }

              const systemPrompt = 'You are an AI code agent for the CRM (PHP/Laravel + frontend). Provide concise, actionable suggestions to create/correct/improve code. Prefer specific steps and concrete code snippets. Highlight risks and missing tests. Keep output under 450 words.';
              const userPrompt = `Repository: ${context.repo.owner}/${context.repo.repo}\nEvent: ${context.eventName}\nBase: ${baseSha}\nHead: ${headSha}\nGoals: create new code, fix issues, and suggest improvements for the CRM.${extraPrompt ? `\nUser prompt: ${extraPrompt}` : ''}\nDiff (git diff base...head):\n${diff}`;

              async function callOpenAI() {
                if (!process.env.OPENAI_API_KEY) {
                  return 'OPENAI_API_KEY secret not found in repository secrets.';
                }
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
                  },
                  body: JSON.stringify({
                    model,
                    messages: [
                      { role: 'system', content: systemPrompt },
                      { role: 'user', content: userPrompt },
                    ],
                    temperature: 0.2,
                    max_tokens: 1200,
                  }),
                });

                if (!response.ok) {
                  const errText = await response.text();
                  core.setFailed(`OpenAI API error: ${response.status} ${response.statusText} - ${errText}`);
                  return null;
                }

                const data = await response.json();
                return data?.choices?.[0]?.message?.content?.trim() || 'No response content.';
              }

              async function callCopilot() {
                if (!process.env.COPILOT_TOKEN) {
                  return 'COPILOT_TOKEN secret not found in repository secrets.';
                }

                const requestId = crypto.randomUUID();
                const response = await fetch('https://api.githubcopilot.com/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${process.env.COPILOT_TOKEN}`,
                    'X-Request-ID': requestId,
                  },
                  body: JSON.stringify({
                    model,
                    messages: [
                      { role: 'system', content: systemPrompt },
                      { role: 'user', content: userPrompt },
                    ],
                    temperature: 0.2,
                    max_tokens: 1200,
                  }),
                });

                if (!response.ok) {
                  const errText = await response.text();
                  core.setFailed(`Copilot API error: ${response.status} ${response.statusText} - ${errText}`);
                  return null;
                }

                const data = await response.json();
                return data?.choices?.[0]?.message?.content?.trim() || 'No response content.';
              }

              let content = null;
              if (provider === 'copilot') {
                content = await callCopilot();
              } else {
                content = await callOpenAI();
              }

              if (!content) {
                return;
              }

              const body = `ðŸ¤– AI Agent (${provider}/${model})\n\n${content}\n\n_Run: ${context.runId}_`;

              if (prNumber) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body,
                });
              } else {
                core.setOutput('analysis', body);
                core.info(body);
              }
            }

            run();
